<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fruit Stand Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f8ff;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
            background-color: white;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        // Your game JavaScript will go here
        console.log("Game starting...");

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
   
    // Game state object goes here
    const game = {
    // ... the game object code
        player: {
            x: 0,      // Grid position (not pixel position)
            y: 0
        },

            
        grid: {
            width: 8,   // 8x6 grid of fruits
            height: 6,
            fruits: []  // We'll fill this with fruit data
        },

        basket: {
        fruits: [],        // What player has collected
        maxCapacity: 10    // Basket gets full at 10 fruits
        },

        orders: [],

        completedOrdersCount: 0,
        gameState: 'playing',
        targetOrdersCount: 3 // How many orders to complete to win
    };
    console.log("Game state created:", game);
    
    const fruitTypes = {
        apple: { name: 'apple', color: 'red' },
        grapes: { name: 'grapes', color: 'purple' },
        banana: { name: 'banana', color: 'yellow' }
    };

    // Function to randomly generate fruits for the grid
    function generateFruitGrid() {
        const fruits = Object.keys(fruitTypes); // ['apple', 'grapes', 'banana']
        game.grid.fruits = [];
        
        for (let y = 0; y < game.grid.height; y++) {
            game.grid.fruits[y] = []; // Create a row
            for (let x = 0; x < game.grid.width; x++) {
                // Pick a random fruit type
                const randomFruit = fruits[Math.floor(Math.random() * fruits.length)];
                game.grid.fruits[y][x] = randomFruit;
            }
        }
    }    

    function drawGrid() {
        const cellSize = 60; // Size of each grid cell in pixels

        for (let y = 0; y < game.grid.height; y++) {
            for (let x = 0; x < game.grid.width; x++) {
                const fruitType = game.grid.fruits[y][x];

                const pixelX = x * cellSize;
                const pixelY = y * cellSize;

                if (fruitType === null) {
                    // Draw empty cell
                    ctx.fillStyle = 'lightgray';
                    ctx.fillRect(pixelX, pixelY, cellSize, cellSize);
                } else {
                    // Draw fruit
                    const fruit = fruitTypes[fruitType];
                    ctx.fillStyle = fruit.color;
                    ctx.fillRect(pixelX, pixelY, cellSize, cellSize);
                }
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.strokeRect(pixelX, pixelY, cellSize, cellSize);
            }
        }
    }
    


    // Function to draw the player
    function drawPlayer() {
        const cellSize = 60;
        const pixelX = game.player.x * cellSize;
        const pixelY = game.player.y * cellSize;
        
        // Draw player as a blue circle in the center of the cell
        ctx.beginPath();
        ctx.arc(pixelX + cellSize/2, pixelY + cellSize/2, 20, 0, Math.PI * 2);
        ctx.fillStyle = 'blue';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.stroke();
    }
    
    // draw a text box
    function drawTextBox(text, x, y, width, height, bgcolor = 'gray') {
        ctx.fillStyle = bgcolor;
        ctx.fillRect(x, y, width, height);

        // Draw border
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);
        
        // Draw text
        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.fillText(text, x + 10, y + 25);
    }

    function drawOrders() {
        const startX = 500;  // Right side of grid
        const startY = 20;
        let currentY = startY;
        
            // Title
        drawTextBox('CURRENT ORDERS:', startX, currentY, 280, 40, '#e6f3ff');
        currentY += 50;

        // Draw each active order
        for (let i = 0; i < game.orders.length; i++) {
            const order = game.orders[i];
            if (!order.completed) {
                let orderText = `Order ${i + 1}: `;

                const fruitNames = Object.keys(fruitTypes);
                const requiredFruits = []
                for (let fruit of fruitNames) {
                    if (order[fruit] > 0) {
                        requiredFruits.push(`${order[fruit]} ${fruit}`);
                    }
                }
                orderText += requiredFruits.join(', ');
                drawTextBox(orderText, startX, currentY, 280, 40, '#fff8dc');
                currentY += 40;
            }
        }
    }

    // Function to draw basket contents
    function drawBasket() {
        const startX = 500;
        const startY = 250;
        
        // Title with capacity
        const basketTitle = `BASKET (${game.basket.fruits.length}/${game.basket.maxCapacity}):`;
        drawTextBox(basketTitle, startX, startY, 280, 40, '#f0fff0');
        
        // Count each fruit type in basket
        const basketCounts = countBasketFruits();
        let currentY = startY + 50;
        
        const fruitNames = Object.keys(fruitTypes);
        for (let fruit of fruitNames) {
            if (basketCounts[fruit] > 0) {
                const fruitText = `${basketCounts[fruit]} ${fruit}`;
                drawTextBox(fruitText, startX, currentY, 280, 30, '#f5f5f5');
                currentY += 35;
            }
        }
        
        // Show game progress
        currentY += 10;
        const progressText = `Orders completed: ${game.completedOrdersCount}/${game.targetOrdersCount}`;
        drawTextBox(progressText, startX, currentY, 280, 30, '#ffe6e6');
    }

    function drawGameEndMessage() {
        const startX = 50;
        const startY = 400;

        if (game.gameState === 'won') {
            endMessage = 'YOU WON!';
        } else {
            endMessage = 'YOU LOST!';
        }
        drawTextBox(endMessage, startX, startY, 280, 40, 'pink');
    }


    document.addEventListener('keydown', function(event) {
        if (event.key === 'r' || event.key === 'R') {
            restartGame();
        }

        if (game.gameState !== 'playing') {
            return;
        }

        let moved = false;
        if (event.key === 'ArrowUp' && game.player.y > 0) {
            game.player.y--;
            moved = true;
        } else if (event.key === 'ArrowDown' && game.player.y < game.grid.height - 1) {
            game.player.y++;
            moved = true;
        } else if (event.key === 'ArrowLeft' && game.player.x > 0) {
            game.player.x--;
            moved = true;
        } else if (event.key === 'ArrowRight' && game.player.x < game.grid.width - 1) {
            game.player.x++;
            moved = true;
        }

        if (moved) {
            console.log("Player moved to:", game.player.x, game.player.y);

            collectFruit();
        }

        // use a complete order keystroke for now
        if (event.key === ' ') {
            tryCompleteOrders();
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawPlayer();
        drawOrders();
        drawBasket();

        if (game.gameState !== 'playing') {
            drawGameEndMessage();
        }
    });

    function restartGame() {
        game.gameState = 'playing';
        game.completedOrdersCount = 0;
        game.orders = [];
        game.basket.fruits = [];
        game.player.x = 0;
        game.player.y = 0;

        generateFruitGrid();
        addNewOrder();

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawPlayer();
        drawOrders();
        drawBasket();
        console.log("Game restarted. Game state now:", game);
    }


    function collectFruit() {
        const playerX = game.player.x;
        const playerY = game.player.y;

        // Check if there's a fruit at this position
        const fruitAtPosition = game.grid.fruits[playerY][playerX];

        if (fruitAtPosition !== null) {
            if (game.basket.fruits.length < game.basket.maxCapacity) {
                game.basket.fruits.push(fruitAtPosition); // add fruit to basket array
                game.grid.fruits[playerY][playerX] = null; // remove fruit from grid
                console.log("Collected fruit:", fruitAtPosition, "Basket:", game.basket.fruits.length +"/"+game.basket.maxCapacity);
                console.log("Basket now contains:", game.basket.fruits);
            } else {
                console.log("Basket is full! Cannot collect", fruitAtPosition);
            }
        }

        checkGameEnd();
    }

    function countBasketFruits() {
        const counts = { apple: 0, grapes: 0, banana: 0 };
        for (let fruit of game.basket.fruits) {
            counts[fruit]++;
        }
        return counts;
    }

    function canCompleteOrder(order, basketCounts) {
        return (basketCounts.apple >= (order.apple || 0)) &&
               (basketCounts.grapes >= (order.grapes || 0)) &&
               (basketCounts.banana >= (order.banana || 0));
    }

    function tryCompleteOrders() {
        const basketCounts = countBasketFruits();
        console.log("Basket counts:", basketCounts);

        for (let i = 0; i < game.orders.length; i++) {
            const order = game.orders[i];
            if (!order.completed && canCompleteOrder(order, basketCounts)) {
                // complete the order
                completeOrder(order);
                console.log("Completed order:", order);

                addNewOrder();

                console.log("Game state now:", game);
                checkGameEnd();
                return;
            }
        }

        console.log("No orders completed right now.");

        checkGameEnd();
    }

    function completeOrder(order) {
        const fruitsToRemove = [];
        for (let i = 0; i < (order.apple || 0); i++) {
            fruitsToRemove.push('apple');
        }
        for (let i = 0; i < (order.grapes || 0); i++) {
            fruitsToRemove.push('grapes');
        }
        for (let i = 0; i < (order.banana || 0); i++) {
            fruitsToRemove.push('banana');
        }

        console.log("Fruits to remove:", fruitsToRemove);

        // remove from basket
        for (let fruitToRemove of fruitsToRemove) {
            const index = game.basket.fruits.indexOf(fruitToRemove);
            if (index !== -1) {
                game.basket.fruits.splice(index, 1);
                console.log("Basket now contains:", game.basket.fruits);
            }
        }

        // mark as completed
        order.completed = true;

        game.completedOrdersCount++;
        console.log("Completed orders count:", game.completedOrdersCount);
    }

    function generateRandomOrder() {
        const order = { completed: false };
        const fruitNames = Object.keys(fruitTypes);

        // randomly choose how many fruit types to include
        const numFruitTypes = Math.floor(Math.random() * fruitNames.length) + 1;

        const shuffledFruits = [...fruitNames].sort(() => Math.random() - 0.5);
        const selectedFruits = shuffledFruits.slice(0, numFruitTypes);
        // randomly select how many of each fruit type to include 
        for (let fruit of selectedFruits) {
            order[fruit] = Math.floor(Math.random() * 3) + 1;
        }
        return order;
    }

    function addNewOrder() {
        const newOrder = generateRandomOrder();
        game.orders.push(newOrder);
        console.log("New order added:", newOrder);
    }

    function checkGameEnd() {
        if (game.completedOrdersCount >= game.targetOrdersCount) {
            game.gameState = 'won';
            console.log("You won the game!");
            return;
        }

        if (game.basket.fruits.length >= game.basket.maxCapacity) {
            const basketCounts = countBasketFruits();
            let canCompleteAny = false;
            for (let order of game.orders) {
                if (!order.completed && canCompleteOrder(order, basketCounts)) {
                    canCompleteAny = true;
                    break;
                }
            }

            if (!canCompleteAny) {
                game.gameState = 'lost';
                console.log("You lost the game!");
                return;
            }
        }

    }






    generateFruitGrid();
    console.log("Fruit grid generated:", game.grid.fruits);
    addNewOrder();
    console.log("Game state now:", game);
    drawGrid();
    drawPlayer();
    drawOrders();
    drawBasket();


    </script>
</body>
</html>
